Summit Pradhan and Alex Huynh

October 29, 2023

CS91S: Games Systems 

Remake

Collaboration Statement: We used the following sources:
    History: https://mentalitch.com/history-of-the-classic-video-game-frogger/
    How the game works: https://en.wikipedia.org/wiki/Frogger

------------------------------------------------------------------

In 1981, Akira Hashimoto, a game developer at Konami, got the concept for Frogger when he, while stuck in traffic, saw a frog trying to cross the road. He then developed the game and presented it to Konami, who then presented it to Gremlin, a game publisher acquired by Sega. Gremlin disliked the game because it was too “basic” and “cute” to be enjoyed by boys. A few weeks later, Elizabeth Falconer saw the game in Gremlin’s library and pushed for it to be published. She was given a chance: Gremlin would publish Frogger if she could convince executives of Paramount, which owned Sega, that the game is fun. She succeeded by reminding the executives of Pac-Man (another “cute” game that became wildly popular), and was given sixty days to play-test Frogger. So, Gremlin paid Konami $3,500 a day for the license and created an arcade cabinet for the game. They brought the arcade cabinet to Spanky’s Saloon in San Diego to test out the game, and it became the most popular game at that bar. This ultimately convinced Gremlin to officially publish Frogger.

In Frogger, the goal is to navigate the frog back home across a road and river in under thirty seconds and without losing all (three, five, or seven depending on the arcade machine’s settings) lives. While on the road, the player has to dodge five rows of moving cars, each moving at different speeds and each either moving left or right. Colliding with these cars results in death. The fifth row has a car that’s twice as long as the other rows’ cars. When the player successfully dodges the cars, there is a safety strip where they can take a break before attempting to cross the five rows of river. To successfully cross the river, they have to hop on the logs or turtles, which will carry the frog while it remains on the floating objects. The turtles occasionally dive into the water, which means standing on them will result in death. Occasionally, one of the logs will be an alligator; it will still function like a log except stepping onto its mouth will result in death. There are also snakes, which move back and forth on the logs or the safety strip, and otters in the river; touching these also results in death. For the final row, the player must guide the frog into one of five homes. If the frog jumps into a home that’s already filled, a home that momentarily has an alligator, or anywhere else that’s not a home, it dies. If the player succeeds, a frog will appear in its home and the player will have to guide another frog. If the player fills all five homes with frogs, they move to the next level. With each successive level, the difficulty increases: the road and river pattern gets busier, and the speed of the obstacles increases. However, every five levels, the difficulty eases before increasing again.

For the player, the objective of the game is to gain as many points as possible. Moving forward rewards ten points, guiding the frog to its home rewards fifty plus ten for each half-second remaining, and guiding all five and moving to the next level rewards 1000. Occasionally, there is a female frog that the player can pick up and carry home, rewarding 200 points. Additionally, a fly may also appear in the homes, and bringing the frog back to said home rewards 200 points.

Our remake captures most of the game. We drew sprites for every object in the game, including frogs, cars, logs, turtles, alligators, snakes, otters, point-boosting items, and all background tiles. We added the five rows of cars and five rows of rivers, the safety strip, and the row of five homes. We also added the objects that each row contains (cars, logs, and turtles), and have these objects move in a certain direction. We added collision detection to tell us when the frog is touching a car, the river objects, and the other obstacles. We also implemented the corresponding events as a result of these collisions: crashing into a car, snake, and alligator results in death, being on a log or turtle will move the frog, and jumping into the river results in drowning. We also added animations for the frog’s jumps, the turtles, the snake, and the alligator. For the turtles, we used random number generation to determine when the turtle does the diving animation and updated the corresponding collision detection event so that the frog dies if it is standing on a diving turtle. We added the win condition: successfully guiding the frog to its home. We also implemented varying level patterns: in each level pattern, there is a different number of cars and obstacles with varying speeds and directions. We tried our best to capture the meaning of “the difficulty eases every five levels before increasing again” by looping through five patterns in order of difficulty over and over again, each loop increasing the speed at which the objects move. We added points for every forward step, every successful trip across the road and river, and every level. We also added the thirty-second timer and gave the player five lives. We added sounds for jumping, reaching the goal, and dying. To ease development, we employed object-oriented programming techniques using Middleclass for the objects (frog and obstacles) and utility functions (row functionality, level patterns, and animation). 

We unfortunately did not have time to implement the otters, the fly and lady frog, the alligator in the homes, and music. We also did not capture the level patterns and difficulty increases one-for-one; instead, we opted to create our own patterns. Because of the limitations of the TIC-80, we were unable to capture the correct size ratio of each sprite. All sprites in the TIC-80 are eight by eight, but the sprites in the original game were all varying in size. To do this, we could manually resize the sprites; however, this would mean complicating the math we would need to implement collision detection. Thus, we opted for ease of implementation over graphical accuracy.
